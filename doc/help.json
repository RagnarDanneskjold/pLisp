{"entries" :
 [
  {"type" : 2, 
   "name" : "abort", 
   "syntax" : "(abort) => NIL",
   "args" : "None",
   "desc" : "Calling abort in debug mode aborts the evaluation of an expression",
   "exceptions" : "None",
   "examples" : [ ],
   "see-also" : [ "break", "resume" ]
  },

  {"type" : 1, 
   "name" : "alias", 
   "syntax" : "(alias var1 var2) => NIL",
   "args" : "var1, var2: symbols",
   "desc" : "alias creates a new binding between var2 and the object bound to var1",
   "exceptions" : "Throws an exception of type SYMBOL-NOT-BOUND if var2 is not bound to a value",
   "examples"   : [ "(define x 100)", "(alias y x)", "y=>100" ],
   "see-also" : [ "define" ]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-char", 
   "syntax" : "(alloc-ext-mem-char n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-char allocates raw memory corresponding to n characters. Equivalent to malloc(n*sizeof(char)). Returns the pointer to the allocated memory via a list that also contains the number of characters allocated (i.e. n) and the type of the memory block (integer 3 signifying a character array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-float", "alloc-ext-mem-int", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell"]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-float", 
   "syntax" : "(alloc-ext-mem-float n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-float allocates raw memory corresponding to n floats. Equivalent to malloc(n*sizeof(float)). Returns the pointer to the allocated memory via a list that also contains the number of floats allocated (i.e. n) and the type of the memory block (integer 2 signifying a float array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-int", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-int", 
   "syntax" : "(alloc-ext-mem-int n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-int allocates raw memory corresponding to n integers. Equivalent to malloc(n*sizeof(int)). Returns the pointer to the allocated memory via a list that also contains the number of integers allocated (i.e. n) and the type of the memory block (integer 1 signifying an integer array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 0, 
   "name" : "get-ext-mem-cell", 
   "syntax" : "(get-ext-mem-cell blk pos) => result",
   "args" : "blk: a list; pos: an integer; result: an object",
   "desc" : "returns the integer, float or character stored in position pos of a native memory block blk that was allocated by one of the alloc-ext-mem-* functions.",
   "exceptions" : "Throws an exception of type INVALID-INDEX if pos not greater than or equal to zero or less than the size of blk. Throws an exception of type EXCEPTION if the block has an invalid type (i. e. not 1, 2 or 3 signifying integer, float or character respectively).",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "alloc-ext-mem-int", "free-ext-mem", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell"]
  },

  {"type" : 0, 
   "name" : "and", 
   "syntax" : "(and form*) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "and performs a logical conjunction of its operands. Returns T if all the operands evaluate to non-NIL and NIL otherwise. Returns T if no arguments are passed",
   "exceptions" : "None",
   "examples" : [ "(and (eq 1 1) (eq 2 2)) => T", "(and () 3) => NIL" ],
   "see-also" : [ "or" ]
  },

  {"type" : 0, 
   "name" : "append", 
   "syntax" : "(append list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "append creates a new list by appending the two lists passed as arguments",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the arguments is not a list",
   "examples" : [ "(append '(a b) '(c d)) => (a b c d)", "(append () '(1 2)) => (1 2)" ],
   "see-also" : [ "concat", "nconc" ]
  },

  {"type" : 2, 
   "name" : "apply", 
   "syntax" : "(apply function args) => result",
   "args" : "function: a form that evaluates to a closure or a continuation; args: a form that evaluates to a list; result: an object",
   "desc" : "apply applies the closure or continuation passed as its first parameter to the arguments passed as its second parameter",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not a closure or a continuation or if the second argument is not a list",
   "examples" : [ "(apply + '(1 2)) => 3" ],
   "see-also" : [ "funcall" ]
  },

  {"type" : 1, 
   "name" : "array", 
   "syntax" : "(array dims default-value) => result",
   "args" : "dims: a list; default-value: an object; result: an array object",
   "desc" : "array creates an array with the dimensions specified by the list dims and populates the elements of the newly-constructed array with default-value",
   "exceptions" : "None",
   "examples" : [ "(define a (array (2 2) 1))", "a => [[1 1] [1 1]]" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "array-eq", 
   "syntax" : "(array-eq arr1 arr1) => result",
   "args" : "arr1, arr2: forms that evaluate to array objects; result: T or NIL",
   "desc" : "array-eq returns T if arr1 and arr2 are structurally equivalent, i.e. they have the same contents, and NIL otherwise",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if either of the arguments is not an array",
   "examples" : [ "a1 => [1, 2]", "a2 => [1, 2]", "a3 => ['a 'b]", "(array-eq a1 a2) => T", "(array-eq a1 a3) => NIL" ],
   "see-also" : [ "eq" ]
  },

  {"type" : 2, 
   "name" : "array-get", 
   "syntax" : "(array-get arr index) => result",
   "args" : "arr: a form that evaluates to an array object; index: a form that evaluates to an integer; result: an object",
   "desc" : "array-get returns the object at the position index of array arr. Note that array indices start from zero",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than (len-1), where len is the length of the array",
   "examples" : [ "a1 => [1, 2]", "(array-get a1 0) => 1" ],
   "see-also" : [ "array-set" ]
  },

  {"type" : 2, 
   "name" : "array-length", 
   "syntax" : "(array-length arr) => result",
   "args" : "arr: a form that evaluates to an array object; result: an integer",
   "desc" : "array-length returns the length of array arr",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array",
   "examples" : [ "a1 => [40, 50]", "(array-length a1) => 2" ],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "array-set", 
   "syntax" : "(array-set arr index form) => form",
   "args" : "arr: a form that evaluates to an array object; index: an integer; form: an object",
   "desc" : "array-set binds the position index of array arr to form",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than (len-1), where len is the length of the array",
   "examples" : [ "a1 => [40, 50]", "(array-set a1 0 30) => 30", "a1 => [30, 50]" ],
   "see-also" : [ "array-get" ]
  },

  {"type" : 2, 
   "name" : "arrayp", 
   "syntax" : "(arrayp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "arrayp returns T if form evaluates to an array and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "a1 => [40, 50]", "(arrayp a1) => T", "(arrayp 10) => NIL" ],
   "see-also" : []
  },

  {"type" : 1, 
   "name" : "aset", 
   "syntax" : "(aset ref val) => val",
   "args" : "ref: an array reference; val: an object",
   "desc" : "aset binds val to the array location referred to by ref",
   "exceptions" : "Throws an exception of type SYMBOL-NOT-BOUND if the array reference is not bound to an array object, and an exception INDEX-OUT-OF-BOUNDS if the index(es) in the reference fall outside the array bounds",
   "examples" : [ "(define a (array (2 2) 0) => A", "a => [[0 0] [0 0]]", "(aset a[0 0] 100) => 100", "a => [[100 0] [0 0]]" ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "assert", 
   "syntax" : "(assert form) => NIL",
   "args" : "form: an object",
   "desc" : "assert throws an exception of type EXCEPTION if form evaluates to NIL",
   "exceptions" : "See above",
   "examples" : [],
   "see-also" : [ ]
  },

  {"type" : 0, 
   "name" : "assoc", 
   "syntax" : "(assoc key pairs) => result",
   "args" : "key: an object; pairs: a list of CONS objects; result: object",
   "desc" : "assoc returns the CDR of the pair in pairs whose CAR equals key and NIL otherwise",
   "exceptions" : "Throws an exception of type EXCEPTION if pairs is not a list of CONS objects",
   "examples" : ["a => ((1 . x) (2 . y))", "(assoc 1 a) => x", "(assoc 3 a) => NIL"],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "atom", 
   "syntax" : "(atom form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "atom returns T if form is an atom and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(atom 1) => T", "(atom '(1 2)) => NIL" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "break", 
   "syntax" : "(break) => NIL",
   "args" : "None",
   "desc" : "break stops the evaluation of the expression and passes control to the Debugger",
   "exceptions" : "None",
   "examples" : [ ],
   "see-also" : [ "abort", "resume" ]
  },

  {"type" : 0, 
   "name" : "butlast", 
   "syntax" : "(butlast lst len) => result",
   "args" : "lst: a form that evaluates to a list; len: an integer; result: a list",
   "desc" : "butlast returns a list that comprises the elements of lst excluding the last len elements",
   "exceptions" : "Throws an exception of type EXCEPTION if lst is not a list or len is not a positive integer smaller than the length of lst",
   "examples" : [ "(butlast '(1 2 3) 1) => (2 3)" ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "caar", 
   "syntax" : "(caar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caar is functionally equivalent to (car (car lst)",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car above is not on a list",
   "examples" : [ "(caar '((1 2) (3, 4)) => 1" ],
   "see-also" : [ "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth"  ]
  },

  {"type" : 0, 
   "name" : "cadar", 
   "syntax" : "(cadar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadar is functionally equivalent to (car (cdr (car lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(cadar '((1 2) (3, 4)) => 2" ],
   "see-also" : [ "caar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadddr", 
   "syntax" : "(cadddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadddr is functionally equivalent to (car (cdr (cdr (cdr lst)))), i.e., the fourth element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr (cdr (cdr '(1 2 3 4))))) => 4" ],
   "see-also" : [ "caar", "cadar", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "caddr", 
   "syntax" : "(caddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caddr is functionally equivalent to (car (cdr (cdr lst))), i.e., the third element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr (cdr '(1 2 3 4)))) => 3" ],
   "see-also" : [ "caar", "cadar", "cadddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadr", 
   "syntax" : "(cadr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadr is functionally equivalent to (car (cdr lst)), i.e., the second element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr '(1 2 3 4))) => 2" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 1, 
   "name" : "call-foreign-function", 
   "syntax" : "(call-foreign-function name return-type params) => result",
   "args" : "name: a form that evaluates to a string; return-type: a symbol; params: a list of CONS objects; result: an object",
   "desc" : "call-foreign-function invokes a native function called name defined in a shared library that was loaded earlier. return-type denotes the return type of the native function ('void, 'integer, 'float, 'character, or 'character-pointer). params contains information about the parameters to the native function (parameter type and object)",
   "exceptions" : "call-foreign-function throws an exception of type EXCEPTION if it is not supplied with three parameters. It throws an exception of type ARG-MISMATCH if the parameters are not of the types as described above. ARG-MISMATCH is also thrown if there are any inconsistencies in the params argument (e.g. the parameter type is integer and the object is not an integer)",
   "examples" : [ "(call-foreign-function some_func void ((ivar integer, fvar float)))" ],
   "see-also" : [ "load-foreign-library" ]
  },

  {"type" : 2, 
   "name" : "call-cc", 
   "syntax" : "(call-cc lambda-exp) => result",
   "args" : "lambda-exp: a form; result: an object",
   "desc" : "call-cc captures the current continuation object and invokes the closure object lambda-exp with this continuation object as the parameter",
   "exceptions" : "None",
   "examples" : [ "(call-cc (lambda (cc) (set cont cc)))" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "car", 
   "syntax" : "(car lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "car returns the first element of a list",
   "exceptions" : "Throws an exception of type NOT-A-CONS if the argument is not a list",
   "examples" : [ "(car '(1 2 3 4)) => 1", "(car nil) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 1, 
   "name" : "cdar", 
   "syntax" : "(cdar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdar is functionally equivalent to (cdr (car lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(cdr (car '((1 2) 3 4))) => (2)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cddr", 
   "syntax" : "(cddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cddr is functionally equivalent to (cdr (cdr lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of cdr above is not on a list",
   "examples" : [ "(cdr (cdr '(1 2 3 4))) => (3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "cdr", 
   "syntax" : "(cdr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdr retuns the list comprising the all the elements of lst except the first one",
   "exceptions" : "Throws an exception of type EXCEPTION if lst is not a list",
   "examples" : [ "(cdr '(1 2 3 4)) => (2 3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "characterp", 
   "syntax" : "(characterp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "characterp returns T if form evaluates to a character and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(characterp #\a) => T", "(characterp 10) => NIL" ],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "clone", 
   "syntax" : "(clone form) => result",
   "args" : "form: an object; result: an object",
   "desc" : "clone makes a deep copy of the object form evaluates to",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(clone '(1 2 3)) => (1 2 3)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "closurep", 
   "syntax" : "(closurep form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "closurep returns T if form evaluates to a closure object and NIL otherwise. Note that special operators are not closures",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(closurep (lambda (x) x)) => T", "(defun double (n) (* n2)) => DOUBLE", "(closurep double) => T", "(closurep 3) => NIL", "(closurep +) => NIL"  ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "concat", 
   "syntax" : "(concat lst &rest lists) => result",
   "args" : "lst: a list; lists: a list of the rest of the arguments, which are themselves lists",
   "desc" : "concat combines the passed lists into a new list",
   "exceptions" : "None",
   "examples" : [ "(concat '(1 2 3) '(4 5 6) '(7 8 9)) => '(1 2 3 4 5 6 7 8 9)" ],
   "see-also" : [ "append", "nconc" ]
  },

  {"type" : 0, 
   "name" : "concat-strings", 
   "syntax" : "(concat-strings str1 str2) => result",
   "args" : "str1, str2: forms that evaluate to strings; result: a string",
   "desc" : "concat-strings combines the two strings passed as arguments into a new string",
   "exceptions" : "None",
   "examples" : [ "(concat-strings \“abc\” \“def\”) => \“abcdef\”" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "cond", 
   "syntax" : "(cond ((cond1 action1) (cond2 action2) ..)) => result",
   "args" : "cond1, cond2, …: forms; action1, action2, …: forms; result: an object",
   "desc" : "cond takes a list comprising condition/action pairs, and evaluates each condition sequentially, stopping at the first condition that evaluates to a non-NIL value. It then evaluates the action corresponding to this condition and returns the result of evaluating that action. If none of the conditions evaluates to a non-NIL value, cond returns NIL. If the last condition is T, the action corresponding to this serves as the default action",
   "exceptions" : "None",
   "examples" : [ "(cond ((eq 1 1) 'true) (t 'false))) => TRUE" ],
   "see-also" : [ "if" ]
  },

  {"type" : 2, 
   "name" : "cons", 
   "syntax" : "(cons obj1 obj2) => result",
   "args" : "obj1, obj2 : objects; result:a CONS object",
   "desc" : "cons creates a CONS object from the two objects passed to it as arguments",
   "exceptions" : "None",
   "examples" : [ "(cons 1 2) => (1 . 2)", "(cons 'a nil) => (A)" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "cons-pair", 
   "syntax" : "(cons-pair list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "cons-pair takes two lists and creates a new list, the elements of which are CONS objects obtained by applying cons on the matched elements of the two lists. If the sizes of the two lists are not the same, the shorter of the two lists is padded with NIL values",
   "exceptions" : "None",
   "examples" : [ "(cons-pair '(a b) '(1 2)) => ((A . 1) (B . 2))", "(cons-pair '(a b c) '(1 2)) => ((A . 1) (B . 2) (C))" ],
   "see-also" : [ "pair" ]
  }

 ]
}