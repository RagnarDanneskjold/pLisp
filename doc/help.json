{"entries" :
 [
  {"type" : 2, 
   "name" : "abort", 
   "syntax" : "(abort) => NIL",
   "args" : "None",
   "desc" : "Calling abort in debug mode aborts the evaluation of an expression",
   "exceptions" : "None",
   "examples" : [ ],
   "see-also" : [ "break", "resume" ]
  },

  {"type" : 1, 
   "name" : "alias", 
   "syntax" : "(alias var1 var2) => NIL",
   "args" : "var1, var2: symbols",
   "desc" : "alias creates a new binding between var2 and the object bound to var1",
   "exceptions" : "Throws an exception of type SYMBOL-NOT-BOUND if var2 is not bound to a value",
   "examples"   : [ "(define x 100)", "(alias y x)", "y=>100" ],
   "see-also" : [ "define" ]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-char", 
   "syntax" : "(alloc-ext-mem-char n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-char allocates raw memory corresponding to n characters. Equivalent to malloc(n*sizeof(char)). Returns the pointer to the allocated memory via a list that also contains the number of characters allocated (i.e. n) and the type of the memory block (integer 3 signifying a character array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-float", "alloc-ext-mem-int", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell"]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-float", 
   "syntax" : "(alloc-ext-mem-float n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-float allocates raw memory corresponding to n floats. Equivalent to malloc(n*sizeof(float)). Returns the pointer to the allocated memory via a list that also contains the number of floats allocated (i.e. n) and the type of the memory block (integer 2 signifying a float array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-int", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 0, 
   "name" : "alloc-ext-mem-int", 
   "syntax" : "(alloc-ext-mem-int n) => (ptr, len, type)",
   "args" : "n: integer, ptr: integer, len: integer, type: integer",
   "desc" : "alloc-ext-mem-int allocates raw memory corresponding to n integers. Equivalent to malloc(n*sizeof(int)). Returns the pointer to the allocated memory via a list that also contains the number of integers allocated (i.e. n) and the type of the memory block (integer 1 signifying an integer array)",
   "exceptions" : "None",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "free-ext-mem", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 0, 
   "name" : "get-ext-mem-cell", 
   "syntax" : "(get-ext-mem-cell blk pos) => result",
   "args" : "blk: a list; pos: an integer; result: an object",
   "desc" : "returns the integer, float or character stored in position pos of a native memory block blk that was allocated by one of the alloc-ext-mem-* functions.",
   "exceptions" : "Throws an exception of type INVALID-INDEX if pos not greater than or equal to zero or less than the size of blk. Throws an exception of type EXCEPTION if the block has an invalid type (i. e. not 1, 2 or 3 signifying integer, float or character respectively).",
   "examples" : [],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "alloc-ext-mem-int", "free-ext-mem", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell"]
  },

  {"type" : 0, 
   "name" : "and", 
   "syntax" : "(and form*) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "and performs a logical conjunction of its operands. Returns T if all the operands evaluate to non-NIL and NIL otherwise. Returns T if no arguments are passed",
   "exceptions" : "None",
   "examples" : [ "(and (eq 1 1) (eq 2 2)) => T", "(and () 3) => NIL" ],
   "see-also" : [ "or" ]
  },

  {"type" : 0, 
   "name" : "append", 
   "syntax" : "(append list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "append creates a new list by appending the two lists passed as arguments",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the arguments is not a list",
   "examples" : [ "(append '(a b) '(c d)) => (a b c d)", "(append () '(1 2)) => (1 2)" ],
   "see-also" : [ "concat", "nconc" ]
  },

  {"type" : 2, 
   "name" : "apply", 
   "syntax" : "(apply function args) => result",
   "args" : "function: a form that evaluates to a closure or a continuation; args: a form that evaluates to a list; result: an object",
   "desc" : "apply applies the closure or continuation passed as its first parameter to the arguments passed as its second parameter",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not a closure or a continuation or if the second argument is not a list",
   "examples" : [ "(apply + '(1 2)) => 3" ],
   "see-also" : [ "funcall" ]
  },

  {"type" : 1, 
   "name" : "array", 
   "syntax" : "(array dims default-value) => result",
   "args" : "dims: a list; default-value: an object; result: an array object",
   "desc" : "array creates an array with the dimensions specified by the list dims and populates the elements of the newly-constructed array with default-value",
   "exceptions" : "None",
   "examples" : [ "(define a (array (2 2) 1))", "a => [[1 1] [1 1]]" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "array-eq", 
   "syntax" : "(array-eq arr1 arr1) => result",
   "args" : "arr1, arr2: forms that evaluate to array objects; result: T or NIL",
   "desc" : "array-eq returns T if arr1 and arr2 are structurally equivalent, i.e. they have the same contents, and NIL otherwise",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if either of the arguments is not an array",
   "examples" : [ "a1 => [1, 2]", "a2 => [1, 2]", "a3 => ['a 'b]", "(array-eq a1 a2) => T", "(array-eq a1 a3) => NIL" ],
   "see-also" : [ "eq" ]
  },

  {"type" : 2, 
   "name" : "array-get", 
   "syntax" : "(array-get arr index) => result",
   "args" : "arr: a form that evaluates to an array object; index: a form that evaluates to an integer; result: an object",
   "desc" : "array-get returns the object at the position index of array arr. Note that array indices start from zero",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than (len-1), where len is the length of the array",
   "examples" : [ "a1 => [1, 2]", "(array-get a1 0) => 1" ],
   "see-also" : [ "array-set" ]
  },

  {"type" : 2, 
   "name" : "array-length", 
   "syntax" : "(array-length arr) => result",
   "args" : "arr: a form that evaluates to an array object; result: an integer",
   "desc" : "array-length returns the length of array arr",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array",
   "examples" : [ "a1 => [40, 50]", "(array-length a1) => 2" ],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "array-set", 
   "syntax" : "(array-set arr index form) => form",
   "args" : "arr: a form that evaluates to an array object; index: an integer; form: an object",
   "desc" : "array-set binds the position index of array arr to form",
   "exceptions" : "Throws an exception of type INVALID-ARGUMENT if the first argument is not an array, and an exception of type INDEX-OUT-OF-BOUNDS if the index is less than zero or greater than (len-1), where len is the length of the array",
   "examples" : [ "a1 => [40, 50]", "(array-set a1 0 30) => 30", "a1 => [30, 50]" ],
   "see-also" : [ "array-get" ]
  },

  {"type" : 2, 
   "name" : "arrayp", 
   "syntax" : "(arrayp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "arrayp returns T if form evaluates to an array and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "a1 => [40, 50]", "(arrayp a1) => T", "(arrayp 10) => NIL" ],
   "see-also" : []
  },

  {"type" : 1, 
   "name" : "aset", 
   "syntax" : "(aset ref val) => val",
   "args" : "ref: an array reference; val: an object",
   "desc" : "aset binds val to the array location referred to by ref",
   "exceptions" : "Throws an exception of type SYMBOL-NOT-BOUND if the array reference is not bound to an array object, and an exception INDEX-OUT-OF-BOUNDS if the index(es) in the reference fall outside the array bounds",
   "examples" : [ "(define a (array (2 2) 0) => A", "a => [[0 0] [0 0]]", "(aset a[0 0] 100) => 100", "a => [[100 0] [0 0]]" ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "assert", 
   "syntax" : "(assert form) => NIL",
   "args" : "form: an object",
   "desc" : "assert throws an exception of type EXCEPTION if form evaluates to NIL",
   "exceptions" : "See above",
   "examples" : [],
   "see-also" : [ ]
  },

  {"type" : 0, 
   "name" : "assoc", 
   "syntax" : "(assoc key pairs) => result",
   "args" : "key: an object; pairs: a list of CONS objects; result: object",
   "desc" : "assoc returns the CDR of the pair in pairs whose CAR equals key and NIL otherwise",
   "exceptions" : "Throws an exception of type EXCEPTION if pairs is not a list of CONS objects",
   "examples" : ["a => ((1 . x) (2 . y))", "(assoc 1 a) => x", "(assoc 3 a) => NIL"],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "atom", 
   "syntax" : "(atom form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "atom returns T if form is an atom and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(atom 1) => T", "(atom '(1 2)) => NIL" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "break", 
   "syntax" : "(break) => NIL",
   "args" : "None",
   "desc" : "break stops the evaluation of the expression and passes control to the Debugger",
   "exceptions" : "None",
   "examples" : [ ],
   "see-also" : [ "abort", "resume" ]
  },

  {"type" : 0, 
   "name" : "butlast", 
   "syntax" : "(butlast lst len) => result",
   "args" : "lst: a form that evaluates to a list; len: an integer; result: a list",
   "desc" : "butlast returns a list that comprises the elements of lst excluding the last len elements",
   "exceptions" : "Throws an exception of type EXCEPTION if lst is not a list or len is not a positive integer smaller than the length of lst",
   "examples" : [ "(butlast '(1 2 3) 1) => (2 3)" ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "caar", 
   "syntax" : "(caar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caar is functionally equivalent to (car (car lst)",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car above is not on a list",
   "examples" : [ "(caar '((1 2) (3, 4)) => 1" ],
   "see-also" : [ "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth"  ]
  },

  {"type" : 0, 
   "name" : "cadar", 
   "syntax" : "(cadar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadar is functionally equivalent to (car (cdr (car lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(cadar '((1 2) (3, 4)) => 2" ],
   "see-also" : [ "caar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadddr", 
   "syntax" : "(cadddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadddr is functionally equivalent to (car (cdr (cdr (cdr lst)))), i.e., the fourth element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr (cdr (cdr '(1 2 3 4))))) => 4" ],
   "see-also" : [ "caar", "cadar", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "caddr", 
   "syntax" : "(caddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "caddr is functionally equivalent to (car (cdr (cdr lst))), i.e., the third element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if any of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr (cdr '(1 2 3 4)))) => 3" ],
   "see-also" : [ "caar", "cadar", "cadddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cadr", 
   "syntax" : "(cadr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cadr is functionally equivalent to (car (cdr lst)), i.e., the second element of a list",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(car (cdr '(1 2 3 4))) => 2" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 1, 
   "name" : "call-foreign-function", 
   "syntax" : "(call-foreign-function name return-type params) => result",
   "args" : "name: a form that evaluates to a string; return-type: a symbol; params: a list of CONS objects; result: an object",
   "desc" : "call-foreign-function invokes a native function called name defined in a shared library that was loaded earlier. return-type denotes the return type of the native function ('void, 'integer, 'float, 'character, or 'character-pointer). params contains information about the parameters to the native function (parameter type and object)",
   "exceptions" : "call-foreign-function throws an exception of type EXCEPTION if it is not supplied with three parameters. It throws an exception of type ARG-MISMATCH if the parameters are not of the types as described above. ARG-MISMATCH is also thrown if there are any inconsistencies in the params argument (e.g. the parameter type is integer and the object is not an integer)",
   "examples" : [ "(call-foreign-function some_func void ((ivar integer, fvar float)))" ],
   "see-also" : [ "load-foreign-library" ]
  },

  {"type" : 2, 
   "name" : "call-cc", 
   "syntax" : "(call-cc lambda-exp) => result",
   "args" : "lambda-exp: a form; result: an object",
   "desc" : "call-cc captures the current continuation object and invokes the closure object lambda-exp with this continuation object as the parameter",
   "exceptions" : "None",
   "examples" : [ "(call-cc (lambda (cc) (set cont cc)))" ],
   "see-also" : []
  },

  {"type" : 2, 
   "name" : "car", 
   "syntax" : "(car lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "car returns the first element of a list",
   "exceptions" : "Throws an exception of type NOT-A-CONS if the argument is not a list",
   "examples" : [ "(car '(1 2 3 4)) => 1", "(car nil) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "cdar", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 1, 
   "name" : "cdar", 
   "syntax" : "(cdar lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdar is functionally equivalent to (cdr (car lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of car or cdr above is not on a list",
   "examples" : [ "(cdr (car '((1 2) 3 4))) => (2)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cddr", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "cddr", 
   "syntax" : "(cddr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cddr is functionally equivalent to (cdr (cdr lst))",
   "exceptions" : "Throws an exception of type EXCEPTION if either of the applications of cdr above is not on a list",
   "examples" : [ "(cdr (cdr '(1 2 3 4))) => (3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cdr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "cdr", 
   "syntax" : "(cdr lst) => result",
   "args" : "lst: a form that evaluates to a list; result: an object",
   "desc" : "cdr retuns the list comprising the all the elements of lst except the first one",
   "exceptions" : "Throws an exception of type EXCEPTION if lst is not a list",
   "examples" : [ "(cdr '(1 2 3 4)) => (2 3 4)" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "first", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 2, 
   "name" : "characterp", 
   "syntax" : "(characterp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "characterp returns T if form evaluates to a character and NIL otherwise",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(characterp #\a) => T", "(characterp 10) => NIL" ],
   "see-also" : [ ]
  },

  {"type" : 2, 
   "name" : "clone", 
   "syntax" : "(clone form) => result",
   "args" : "form: an object; result: an object",
   "desc" : "clone makes a deep copy of the object form evaluates to",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(clone '(1 2 3)) => (1 2 3)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "closurep", 
   "syntax" : "(closurep form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "closurep returns T if form evaluates to a closure object and NIL otherwise. Note that special operators are not closures",
   "exceptions" : "Throws an exception of type COMPILE-ERROR if no arguments are supplied",
   "examples" : [ "(closurep (lambda (x) x)) => T", "(defun double (n) (* n2)) => DOUBLE", "(closurep double) => T", "(closurep 3) => NIL", "(closurep +) => NIL"  ],
   "see-also" : []
  },

  {"type" : 0, 
   "name" : "concat", 
   "syntax" : "(concat lst &rest lists) => result",
   "args" : "lst: a list; lists: a list of the rest of the arguments, which are themselves lists",
   "desc" : "concat combines the passed lists into a new list",
   "exceptions" : "None",
   "examples" : [ "(concat '(1 2 3) '(4 5 6) '(7 8 9)) => '(1 2 3 4 5 6 7 8 9)" ],
   "see-also" : [ "append", "nconc" ]
  },

  {"type" : 0, 
   "name" : "concat-strings", 
   "syntax" : "(concat-strings str1 str2) => result",
   "args" : "str1, str2: forms that evaluate to strings; result: a string",
   "desc" : "concat-strings combines the two strings passed as arguments into a new string",
   "exceptions" : "None",
   "examples" : [ "(concat-strings \“abc\” \“def\”) => \“abcdef\”" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "cond", 
   "syntax" : "(cond ((cond1 action1) (cond2 action2) ..)) => result",
   "args" : "cond1, cond2, …: forms; action1, action2, …: forms; result: an object",
   "desc" : "cond takes a list comprising condition/action pairs, and evaluates each condition sequentially, stopping at the first condition that evaluates to a non-NIL value. It then evaluates the action corresponding to this condition and returns the result of evaluating that action. If none of the conditions evaluates to a non-NIL value, cond returns NIL. If the last condition is T, the action corresponding to this serves as the default action",
   "exceptions" : "None",
   "examples" : [ "(cond ((eq 1 1) 'true) (t 'false))) => TRUE" ],
   "see-also" : [ "if" ]
  },

  {"type" : 2, 
   "name" : "cons", 
   "syntax" : "(cons obj1 obj2) => result",
   "args" : "obj1, obj2 : objects; result:a CONS object",
   "desc" : "cons creates a CONS object from the two objects passed to it as arguments",
   "exceptions" : "None",
   "examples" : [ "(cons 1 2) => (1 . 2)", "(cons 'a nil) => (A)" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "cons-pair", 
   "syntax" : "(cons-pair list1 list2) => result",
   "args" : "list1, list2: forms that evaluate to lists; result: a list",
   "desc" : "cons-pair takes two lists and creates a new list, the elements of which are CONS objects obtained by applying cons on the matched elements of the two lists. If the sizes of the two lists are not the same, the shorter of the two lists is padded with NIL values",
   "exceptions" : "None",
   "examples" : [ "(cons-pair '(a b) '(1 2)) => ((A . 1) (B . 2))", "(cons-pair '(a b c) '(1 2)) => ((A . 1) (B . 2) (C))" ],
   "see-also" : [ "pair" ]
  },

  {"type" : 2, 
   "name" : "consp", 
   "syntax" : "(consp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "consp returns T if form evaluates to a CONS object and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(define a (cons 1 2)) => A", "(consp a) => T", "(consp 10) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "continuationp", 
   "syntax" : "(continuationp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "continuationp returns T if form evaluates to a continuation object and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(define cont nil) => CONT", "(progn (call-cc (lambda (cc) (set cont cc))) (print 1)) => 1", "(continuationp cont) => T" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "create-image", 
   "syntax" : "(create-image file-name) => result",
   "args" : "file-name: a string object; result: NIL",
   "desc" : "create-image saves the current state of the pLisp system to a file called file-name",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied or if the argument is not a string object",
   "examples" : [ "(create-image \“plisp.image\”) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "create-package", 
   "syntax" : "(create-package package-name) => result",
   "args" : "package-name: string; result: string",
   "desc" : "create-package creates a new package with the name package-name. It returns the name of the newly-created package",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied or if the argument is not a string object. An exception of type PACKAGE-ALREADY-EXISTS is thrown if the package with name package-name already exists",
   "examples" : [ "(create-package \“pkg\”) => \“PKG\”" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "define", 
   "syntax" : "(define var form) => var",
   "args" : "var: a symbol; form: a form; result: NIL",
   "desc" : "define evaluates form and binds the result of this evaluation to var in the current environment",
   "exceptions" : "Throws en exception of type INVALID-ARGUMENT if var is not a symbol",
   "examples" : [ "(define x 100) => 100", "x => 100" ],
   "see-also" : [ "alias" ]
  },

  {"type" : 1, 
   "name" : "defmacro", 
   "syntax" : "(defmacro name params &rest body) => result",
   "args" : "name: symbol; params: list; body: the rest of the arguments converted into a list; result: a macro object",
   "desc" : "defmacro creates a macro named name with parameters params and body body",
   "exceptions" : "None",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => FIRST" ],
   "see-also" : [ "defun" ]
  },

  {"type" : 1, 
   "name" : "defun", 
   "syntax" : "(defun name params &rest body) => result",
   "args" : "name: symbol; params: list; body: the rest of the arguments converted into a list; result: a closure object",
   "desc" : "defun creates a function named 'name' with parameters 'params' and body 'body'",
   "exceptions" : "None",
   "examples" : [ "(defun double (n) (* n 2)) => DOUBLE" ],
   "see-also" : [ "defmacro" ]
  },

  {"type" : 1, 
   "name" : "dolist", 
   "syntax" : "(dolist spec &rest body) => result",
   "args" : "spec: a list; body: the rest of the arguments converted into a list; result: an object",
   "desc" : "dolist evaluates the code in body for each element in the list specified in the CDR of spec, with the value of the element bound to the symbol specified in the CAR of spec. It returns the result of the last evaluation of body",
   "exceptions" : "None",
   "examples" : [ "(dolist (x '(1 2 3)) (print x)) =>", "1", "2", "3", "NIL" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "dotimes", 
   "syntax" : "(dotimes spec &rest body) => result",
   "args" : "spec: a list; body: the rest of the arguments converted into a list; result: an object",
   "desc" : "dotimes initializes the variable specified in the CAR of spec to zero, and evaluates body with the variable bound to this value. It then successively increments the variable and evaluates body till the value of the variable exceeds the value specified in the CDR of spec. It returns the value of the last evaluation of body",
   "exceptions" : "None",
   "examples" : [ "(dotimes (x 3) (print x)) =>", "0", "1", "2", "NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "eq", 
   "syntax" : "(eq form1 form2) => result",
   "args" : "form1, form2: forms; result: T or NIL",
   "desc" : "eq returns T if form1 and form2 are structurally equivalent and NIL otherwise",
   "exceptions" : "None",
   "examples" : [ "(eq 1 1) => T", "(eq '(1 2) '(1 2) => T", "(define x “abc”) => X", "(eq x “abc”) => T", "(eq 1 'a) => NIL" ],
   "see-also" : [ "array-eq" ]
  },

  {"type" : 2, 
   "name" : "error", 
   "syntax" : "(error str) => result",
   "args" : "str: form that evaluates to a string; result: NIL",
   "desc" : "error creates and throws an exception of type EXCEPTION using str",
   "exceptions" : "None",
   "examples" : [ "(error “Divide by zero”) => -" ],
   "see-also" : [ "throw" ]
  },

  {"type" : 2, 
   "name" : "eval", 
   "syntax" : "(eval form) => result",
   "args" : "form: a form; result: an object",
   "desc" : "eval compiles and evaluates the form 'form'",
   "exceptions" : "None",
   "examples" : [ "(eval '(+ 1 1)) => 2" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "exception", 
   "syntax" : "(exception sym str) => result",
   "args" : "sym: a symbol; str: a string; result: an exception object",
   "desc" : "exception creates an exception object from the passed symbol and string and returns it",
   "exceptions" : "None",
   "examples" : [ "(exception 'exception “An exception”) => (EXCEPTION . “An exception”)" ],
   "see-also" : [ "error" ]
  },

  {"type" : 2, 
   "name" : "expand-macro", 
   "syntax" : "(expand-macro form) => result",
   "args" : "form: a form; result: a form",
   "desc" : "expand-macro expands the macro application represented by form and returns the result of this expansion. Note that the expansion is only at the first level, i.e. if the expanded form contains any macros, they will not be expanded",
   "exceptions" : "None",
   "examples" : [ "(defmacro first (lst) `(car ,lst)) => FIRST", "(expand-macro '(first some-list)) => (CAR SOME-LIST)" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "fifth", 
   "syntax" : "(fifth lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "fifth returns the fifth element of 'lst'",
   "exceptions" : "None",
   "examples" : [ "(fifth '(1 2 3 4 5 6)) => 5" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fourth" ]
  },

  {"type" : 0, 
   "name" : "find", 
   "syntax" : "(find e lst predicate) => result",
   "args" : "e: an object: lst: a list; predicate: a closure or a special operator; result: an object",
   "desc" : "find returns the first element of lst for which predicate returns true when applied to that element and e and NIL if no such element is found",
   "exceptions" : "None",
   "examples" : [ "(find 3 '(1 2 3) <) => 1" ],
   "see-also" : [ "find-if" ]
  },

  {"type" : 0, 
   "name" : "find-if", 
   "syntax" : "(find-if predicate lst) => result",
   "args" : "predicate: a closure or a special operator; lst: a list; result: an object",
   "desc" : "find-if returns the first element of lst for which predicate returns true and NIL if no such element is found",
   "exceptions" : "None",
   "examples" : [ "(find-if (lambda (x) (stringp x)) '(1 \“abc\” 'X)) => \“abc\”" ],
   "see-also" : [ "find" ]
  },

  {"type" : 0, 
   "name" : "first", 
   "syntax" : "(first lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "first returns the first element of a list",
   "exceptions" : "None",
   "examples" : [ "(first '(1 2 3)) => 1", "(first ()) => NIL" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "second", "third", "fourth", "fifth" ]
  },

  {"type" : 0, 
   "name" : "flatten", 
   "syntax" : "(flatten lst) => result",
   "args" : "lst: a list; result: a list",
   "desc" : "flatten converts the sublists of 'lst' into individual elements",
   "exceptions" : "None",
   "examples" : [ "(flatten '((1 2 3) (4 5 6) (7 8 9)) => (1 2 3 4 5 6 7 8 9)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "floatp", 
   "syntax" : "(floatp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "floatp returns T if form evaluates to a float and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(floatp 3.14) => T", "(floatp #\a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 1, 
   "name" : "for", 
   "syntax" : "(for (var init-form cond step-form ret-form) &rest body ) => result",
   "args" : "var: symbol; init-form, cond, step-form, ret-form: forms; body: rest of the arguments; result: an object",
   "desc" : "for loops through the execution of 'body', binding 'var' to the value of 'init-form' and updating its value by evaluating 'step-form'. After every execution of 'body', 'cond' is checked, and execution stops if 'cond' evaluates to NIL. Finally 'ret-form' is evaluated and returned",
   "exceptions" : "None",
   "examples" : [ "(for (i 0 (< i 3) (incf i) nil) (print i)) =>", "0", "1", "2", "NIL" ],
   "see-also" : [ "dotimes" ]
  },

  {"type" : 2, 
   "name" : "format", 
   "syntax" : "(format fd str &rest args) => NIL",
   "args" : "fd: an integer; str: a form that evaluates to a string; args: rest of the arguments in list form",
   "desc" : "format sends the formatted output specified by the format string 'str' and the arguments to the file specified by the file descriptor 'fd' or to standard output if 'fd' is NIL. The format string is modeled identically to the C format string used in printf and fprintf statements",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if two arguments are not supplied. Throws an exception of type INVALID-ARGUMENT if a) the first argument is neither an integer nor NIL, b) if the second argument is not a string or c) args contains any objects other than integers, floats, characters or strings",
   "examples" : [ "(define x 100)", "(format nil “%d” x) =>", "100NIL" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "fourth", 
   "syntax" : "(fourth lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "fourth returns the fourth element of 'lst'",
   "exceptions" : "None",
   "examples" : [ "(fourth '(1 2 3 4 5 6)) => 4" ],
   "see-also" : [ "caar", "cadar", "cadddr", "caddr", "cadr", "car", "cdar", "cddr", "cdr", "first", "second", "third", "fifth" ]
  },

  {"type" : 0, 
   "name" : "free-ext-mem", 
   "syntax" : "(free-ext-mem blk) => NIL",
   "args" : "blk: a list",
   "desc" : "free-ext-mem frees the native memory block specified by 'blk' that was allocated by one of the alloc-ext-mem-* functions",
   "exceptions" : "None",
   "examples" : [  ],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "alloc-ext-mem-int", "get-ext-mem-cell", "inspect-ext-mem", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 0, 
   "name" : "funcall", 
   "syntax" : "(funcall function &rest args) => result",
   "args" : "function: a form that evaluates to a closure, a special operator or a continuation, args: the rest of the arguments converted into a list; result: an object",
   "desc" : "funcall applies the function 'fn' to args",
   "exceptions" : "None",
   "examples" : [ "(funcall (lambda (x y) (+ x y)) 1 2) => 3" ],
   "see-also" : [ "apply" ]
  },

  {"type" : 2, 
   "name" : "gensym", 
   "syntax" : "(gensym) => result",
   "args" : "result: a symbol",
   "desc" : "gensym creates a new symbol that is guaranteed to be unique",
   "exceptions" : "None",
   "examples" : [ "(gensym) => #:G00027194" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "if", 
   "syntax" : "(if cond then else) => result",
   "args" : "cond, then, else: forms; result: an object",
   "desc" : "if evaluates 'cond', and if 'cond' evaluates to a non-NIL value, evaluates 'then', otherwise evaluates 'else'",
   "exceptions" : "None",
   "examples" : [ "(if (> 2 1) 'true 'false) => TRUE" ],
   "see-also" : [ "cond" ]
  },

  {"type" : 2, 
   "name" : "in-package", 
   "syntax" : "(in-package package-name) => NIL",
   "args" : "package-name: a form that evaluates to a string",
   "desc" : "in-package sets the current package to 'package-name'",
   "exceptions" : "Throws an exception of type ACCESS-VIOLATION if package-name is “CORE”. Throws an exception of type EXCEPTION if package-name does not exist",
   "examples" : [ "(in-package “some-package”) => NIL" ],
   "see-also" : [ "create-package" ]
  },

  {"type" : 1, 
   "name" : "incf", 
   "syntax" : "(incf var) => result",
   "args" : "var: symbol; result: an integer or float",
   "desc" : "incf increments 'var' by one",
   "exceptions" : "Throws an exception if var is not bound to an integer or a float",
   "examples" : [ "(define x 0) => X", "(incf x) => 1", "X => 1" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "inspect-ext-mem", 
   "syntax" : "(inspect-ext-mem blk ) => NIL",
   "args" : "blk: a list",
   "desc" : "inspect-ext-mem prints the contents of a native memory block 'blk' that was allocated by one of the alloc-ext-mem-* functions",
   "exceptions" : "Throws an exception of type EXCEPTION if the block has an invalid type (i. e. not 1, 2 or 3 signifying integer, float or character respectively)",
   "examples" : [  ],
   "see-also" : [ "alloc-ext-mem-char", "alloc-ext-mem-float", "alloc-ext-mem-int", "free-ext-mem", "get-ext-mem-cell", "set-ext-mem", "set-ext-mem-cell" ]
  },

  {"type" : 2, 
   "name" : "integerp", 
   "syntax" : "(integerp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "integerp returns T if 'form' evaluates to an integer and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(integerp 3) => T", "(integerp #\a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "lambda", 
   "syntax" : "(lambda params &rest body) => result",
   "args" : "params: a list; body: the rest of the arguments converted into a list; result: a closure object",
   "desc" : "lambda creates a function object with params and body",
   "exceptions" : "None",
   "examples" : [ "(lambda double (n) (* n 2)) => <funciton>" ],
   "see-also" : [  ]
  },

  {"type" : 0, 
   "name" : "last", 
   "syntax" : "(last lst) => result",
   "args" : "lst: a list; result: an object",
   "desc" : "last returns the last element of 'lst'",
   "exceptions" : "None",
   "examples" : [ "(last '(1 2 3)) => 3", "(last '()) => NIL" ],
   "see-also" : [ "last-n" ]
  },

  {"type" : 0, 
   "name" : "last-n", 
   "syntax" : "(last-n lst n) => result",
   "args" : "lst: a list; n: an integer; result: a list",
   "desc" : "last-n returns the last 'n' elements of 'lst'",
   "exceptions" : "None",
   "examples" : [ "(last '(1 2 3) 2) => (2 3)" ],
   "see-also" : [ "last" ]
  },

  {"type" : 0, 
   "name" : "length", 
   "syntax" : "(length lst) => result",
   "args" : "lst: a list; result: an integer",
   "desc" : "length returns the number of elements in 'lst'",
   "exceptions" : "None",
   "examples" : [ "(length '(1 2 3 4 5)) => 5", "(length '()) => 0" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "let", 
   "syntax" : "(let decls &rest body) => result",
   "args" : "decls: a form; body: rest of the arguments converted into a list; result: an object",
   "desc" : "let executes 'body' after binding the definitions in 'decl'",
   "exceptions" : "None",
   "examples" : [ "(let ((x 10) (y 20)) (+ x y)) => 30" ],
   "see-also" : [ "let1" ]
  },

  {"type" : 1, 
   "name" : "let1", 
   "syntax" : "(let1 decls &rest body) => result",
   "args" : "decls: a form; body: rest of the arguments converted into a list; result: an object",
   "desc" : "let1 executes 'body' after binding the definitions in 'decl'. let1 is similar to let, but variables in 'decl' can refer to variables declared earlier",
   "exceptions" : "None",
   "examples" : [ "(let1 ((x 10) (y (+ x 10))) (+ x y)) => 30" ],
   "see-also" : [ "let" ]
  },

  {"type" : 2, 
   "name" : "list", 
   "syntax" : "(list &rest elems) => result",
   "args" : "elems: arguments converted into a list; result: a list",
   "desc" : "list creates a list of the elements in 'elems'",
   "exceptions" : "None",
   "examples" : [ "(list 'a 'b 'c) => (A B C)" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "listp", 
   "syntax" : "(listp form) => result",
   "args" : "form: an object; result: T or NIL",
   "desc" : "listp returns T if 'form' evaluates to a list and NIL otherwise",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied",
   "examples" : [ "(listp '(1 2 3)) => T", "(listp '()) => T", "(listp 'a) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "load-file", 
   "syntax" : "(load-file str) => NIL",
   "args" : "str: a form that evaluates to a string",
   "desc" : "load-file loads the file named 'str' and evaluates the expressions defined in the file",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. Exceptions of type FILE-OPEN-ERROR and FILE-READ-ERROR are thrown if the file cannot be opened or read respectively",
   "examples" : [ "(load-file “1.lisp”) => NIL" ],
   "see-also" : [  ]
  },

  {"type" : 2, 
   "name" : "load-foreign-library", 
   "syntax" : "(load-foreign-library str) => NIL",
   "args" : "str: a form that evaluates to a string",
   "desc" : "load-foreign-library loads the shared library file named 'str'",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the maximum number of foreign libraries that can be loaded is exceeded. An OUT-OF-MEMOY exception is thrown if there is no memory to allocate for the structures internally needed to load the foreign library. An FFI-OPEN-FAILED exception is thrown if the shared library is an invalid file",
   "examples" : [ "(load-foreign-library “somelib.so”) => NIL" ],
   "see-also" : [ "call-foreign-function" ]
  },

  {"type" : 2, 
   "name" : "load-object", 
   "syntax" : "(load-object str) => result",
   "args" : "str: a form that evaluates to a string; result: an object",
   "desc" : "load-object loads the object serialized in the file named 'str'",
   "exceptions" : "Throws an exception of type ARG-MISMATCH if no arguments are supplied. Throws an exception of type INVALID-ARGUMENT if the argument is not a string. An exception of type EXCEPTION is thrown if the file is not a valid file (created using save-object)",
   "examples" : [ "(load-object “object.lisp”) => <an object>" ],
   "see-also" : [ "save-object" ]
  }
 ]
}